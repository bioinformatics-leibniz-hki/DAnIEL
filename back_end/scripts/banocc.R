#!/usr/bin/env Rscript

# Copyright by Daniel Loos
#
# Research Group Systems Biology and Bioinformatics - Head: Assoc. Prof. Dr. Gianni Panagiotou
# https://www.leibniz-hki.de/en/systembiologie-und-bioinformatik.html
# Leibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Institute (HKI)
# Adolf-Reichwein-Straße 23, 07745 Jena, Germany
#
# The project code is licensed under BSD 2-Clause.
# See the LICENSE file provided with the code for the full license.

#
# BAnOCC correlation analysis
#

library(tidyverse)
library(magrittr)
library(banocc)
library(rstan)
library(optparse)

args <- base::list(
  optparse::make_option(
    opt_str = "--features-raw-csv",
    type = "character",
    default = "/dev/stdin",
    help = "Feature abundance matrix with raw counts (CSV)"
  ),
  optparse::make_option(
    opt_str = c("-o", "--results-csv"),
    type = "character",
    default = "/dev/stdout",
    help = "Output correlation table with statistics (CSV)"
  ),
  optparse::make_option(
    opt_str = "--convergence-plot",
    type = "character",
    help = "Convergence plot of iteration trace (e.g. PDF, PNG)"
  ),
  optparse::make_option(
    opt_str = "--stat-summary-csv",
    type = "character",
    help = "Summary about convergence statistics (CSV)"
  ),
  optparse::make_option(
    opt_str = "--chains",
    type = "integer",
    default = 10,
    help = "Number of markov chains"
  ),
  optparse::make_option(
    opt_str = "--iters",
    type = "integer",
    default = 1000,
    help = "Number of iterations"
  ),
  optparse::make_option(
    opt_str = "--warmup",
    type = "integer",
    default = 300,
    help = "Number of warmup iterations"
  ),
  optparse::make_option(
    opt_str = "--conf-alpha",
    type = "double",
    default = 0.95,
    help = "Alpha score to calculate confidence intervals"
  ),
  optparse::make_option(
    opt_str = "--out-rdata",
    type = "character",
    help = "R environment of BAnOCC (RDATA)"
  ),
  optparse::make_option(
    opt_str = "--out-rds",
    type = "character",
    help = "R object generated by banocc::get_banocc_output (RDS)"
  ),
  optparse::make_option(
    opt_str = c("-t", "--threads"),
    type = "integer",
    help = "Number of threads to use (Max one per chain)"
  )
) %>%
  optparse::OptionParser(
    option_list = .,
    description = "BAnOCC correlation between features"
  ) %>%
  optparse::parse_args(convert_hyphens_to_underscores = TRUE)

# args <- list(
#     features_raw_csv = "~/prj/6-its-web-server/userdat/poster/features/Species_low_prev/features.raw.csv",
#     results_csv = "~/prj/6-its-web-server/userdat/poster/analysis/Default_analysis/correlation/results.csv",
#     convergence_plot = "~/prj/6-its-web-server/userdat/poster/analysis/Default_analysis/correlation/banocc_convergence.png",
#     stat_summary_csv = "~/prj/6-its-web-server/userdat/poster/analysis/Default_analysis/correlation/banocc_summary.csv",
#     chains = 10,
#     iters = 1000,
#     warmup = 300,
#     conf_alpha = 0.95,
#     threads = 5
# )

message("Loading BAnOCC STAN model")
compiled_banocc_model <- rstan::stan_model(model_code = banocc::banocc_model)

feature_mat <-
  readr::read_csv(args$features_raw_csv) %>%
  tidyr::gather(feature, abundance, -sample_id) %>%
  # TSS normalization
  dplyr::group_by(sample_id) %>%
  dplyr::mutate(abundance = abundance / base::sum(abundance)) %>%
  # filter samples w/o counts
  dplyr::filter(!is.na(abundance)) %>%
  # to matrix
  tidyr::spread(feature, abundance, fill = 0) %>%
  dplyr::ungroup() %>%
  magrittr::set_rownames(.$sample_id) %>%
  dplyr::select(-sample_id) %>%
  base::as.matrix()

features <- colnames(feature_mat)
p <- length(features)

message("Run BAnOCC model on data set")
b_fit <- banocc::run_banocc(
  C = feature_mat,
  compiled_banocc_model = compiled_banocc_model,
  chains = args$chains,
  iter = args$iters,
  warmup = args$warmup,
  cores = base::min(args$threads, args$chains),
  verbose = TRUE
)

b_out <- banocc::get_banocc_output(banoccfit = b_fit, conf_alpha = args$conf_alpha, calc_snc = TRUE)
pars <- b_fit$Fit %>%
  names() %>%
  grep("^O", ., value = TRUE) %>%
  head(8)

b_convergence_plt <-
  rstan::traceplot(b_fit$Fit, pars = pars, inc_warmup = TRUE) +
  ggplot2::theme_minimal() +
  ggplot2::scale_color_viridis_d() +
  labs(
    title = "BAnOCC Convergence: Precision per feature",
    subtitle = sprintf("%i chains, %i iterations (including %i for warmup)", args$chains, args$iters, args$warmup),
    color = "Chain",
    x = "Iteration",
    y = ""
  )

out_dir <- base::dirname(args$convergence_plot)
if (!dir.exists(out_dir)) {
  dir.create(out_dir, recursive = TRUE)
}
ggplot2::ggsave(args$convergence_plot, b_convergence_plt, width = 10, height = 8, dpi = 300)

b_stat_tbl <-
  rstan::summary(b_fit$Fit)$summary %>%
  dplyr::as_tibble(rownames = "id") %T>%
  readr::write_csv(args$stat_summary_csv)

#' Triangulize matrix to tibble
#' Keep only unique correlation pairs
#' Remove autocorrelations
#' @param unit_name name of value column
triangulize_cor_mat <- function(cor_mat, unit_name) {
  cor_mat %>%
    dplyr::as_tibble(rownames = "feature_a") %>%
    tidyr::gather(feature_b, !!unit_name, -feature_a) %>%
    # correlation matrix is symmetric. Keep only one triangle
    dplyr::rowwise() %>%
    dplyr::mutate(comp = base::c(feature_a, feature_b) %>% base::sort() %>% base::paste0(collapse = "")) %>%
    dplyr::group_by(comp) %>%
    dplyr::slice(1) %>%
    dplyr::ungroup() %>%
    dplyr::select(-comp) %>%
    # filter obvious auto correlations
    dplyr::filter(!feature_a == feature_b)
}

b_result_tbl <-
  b_out$Estimates.median %>%
  triangulize_cor_mat(unit_name = "cor") %>%
  dplyr::ungroup() %>%
  dplyr::mutate(
    p_value = NA,
    q_value = stats::p.adjust(p_value, method = "fdr")
  ) %>%
  dplyr::full_join(
    y = b_out$SNC %>% triangulize_cor_mat(unit_name = "SNC"),
    by = c("feature_a", "feature_b")
  ) %>%
  dplyr::full_join(
    y = b_out$CI.hpd$lower %>% triangulize_cor_mat(unit_name = "CI_min"),
    by = c("feature_a", "feature_b")
  ) %>%
  dplyr::full_join(
    y = b_out$CI.hpd$upper %>% triangulize_cor_mat(unit_name = "CI_max"),
    by = c("feature_a", "feature_b")
  ) %T>%
  readr::write_csv(args$results_csv)

save.image(args$out_rdata)
readr::write_rds(b_out, args$out_rds, compress = "gz")
