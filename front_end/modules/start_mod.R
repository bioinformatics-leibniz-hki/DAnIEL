# !/usr/bin/env R

# Copyright by Daniel Loos
#
# Research Group Systems Biology and Bioinformatics - Head: Assoc. Prof. Dr. Gianni Panagiotou
# https://www.leibniz-hki.de/en/systembiologie-und-bioinformatik.html
# Leibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Institute (HKI)
# Adolf-Reichwein-Straße 23, 07745 Jena, Germany
#
# The project code is licensed under BSD 2-Clause.
# See the LICENSE file provided with the code for the full license.

#
# Module to customize start settings and run analysis
#

# BUG: shiny::conditionalPanel does not work. JavaScript throws Reference Error
# WORKAROUND: Use shiny::uiOutput in UI and shiny::renderUI in server

# BUG: input object in server function can not access values of ui panels which are hidden occasionally
# WORKARROUND: hard code name space start_mod to banocc, sparcc, and blast panels and use default params in save_project_json
# Module must now be called start_mod. Otherwise server function can not access those values

#' default parameters for unexposed inputs
DEFAULT_ANALYSIS_PARAM_SET <- list(
  max_pvalue = 0.05,
  correlation_min_samples = 2,
  correlation_min_features = 5,
  correlation_min_abs_cor = 0.2
)

#' UI ids for QC parameters
QC_PARAM_SET <- c(
  "phred_format", "adapter_fasta", "include_revcomp_primers",
  "min_read_length", "qc_error_rate",
  "min_quality_trailing", "min_quality_leading", "additional_adapter_files",
  "min_qc_read_count", "qc_exclusion_criteria"
)

#' UI ids for denoising parameters
DENOISING_PARAM_SET <- c(
  "its_region", "denoising_method", "include_singletons", "identity_threshold",
  "max_n", "min_q", "max_ee", "trunc_q"
)

#' UI ids for phylotyping parameters
PHYLOTYPING_PARAM_SET <- c(
  "ref_database", "sequence_classifier", "frac_identity"
)

#' UI ids for features parameters
FEATURES_PARAM_SET <- c(
  "taxonomic_rank", "phylo_database", "normalization_method",
  "min_abundance", "min_prevalence", "group_prevalence", "unknown_strategy"
)

#' UI ids for analysis parameters
ANALYSIS_PARAM_SET <- c(
  "correlation_method", "correlation_grouping",
  "banocc_chains", "banocc_iters", "banocc_warmup",
  "banocc_alpha", "sparcc_repetitions"
)

ALL_PARAM_SET <-
  c(
    QC_PARAM_SET,
    DENOISING_PARAM_SET,
    PHYLOTYPING_PARAM_SET,
    FEATURES_PARAM_SET,
    ANALYSIS_PARAM_SET
  )

#' names for parameter sets
SELECTED_STEPS <- list(
  qc = "selected_qc",
  denoising = "selected_denoising",
  phylotyping = "selected_phylotyping",
  features = "selected_features",
  analysis = "selected_analysis"
)

panel_banocc <- function(ns = shiny::NS("start_mod")) {
  shiny::div(
    shiny::numericInput(
      inputId = ns("banocc_chains"),
      label = "BAnOCC chains",
      value = 10,
      min = 1,
      max = 20,
      step = 1
    ) %>% update_label(),
    shiny::numericInput(
      inputId = ns("banocc_iters"),
      label = "BAnOCC total iterations",
      value = 1e3,
      min = 1,
      max = 10e3,
      step = 1
    ) %>% update_label(),
    shiny::numericInput(
      inputId = ns("banocc_warmup"),
      label = "BAnOCC warmup iterations",
      value = 5e3,
      min = 1,
      step = 1
    ) %>% update_label(),
    shiny::numericInput(
      inputId = ns("banocc_alpha"),
      label = "BAnOCC alpha confidence",
      value = 0.95,
      min = 0,
      max = 1,
      step = 0.01
    ) %>% update_label()
  )
}

panel_sparcc <- function(ns = NS("start_mod")) {
  shiny::div(
    shiny::numericInput(
      inputId = ns("sparcc_repetitions"),
      label = "SparCC iterations and bootstraps",
      value = 200,
      min = 1,
      max = 1e3,
      step = 1
    ) %>% update_label()
  )
}

#' @param ns name space as generated by shiny::NS
panel_analysis <- function(ns, ...) {
  shinyBS::bsCollapsePanel(
    ...,
    title = "Analysis",
    shiny::textInput(
      inputId = ns("correlation_grouping"),
      label = "Correlation grouping",
      value = "all"
    ) %>% update_label(),
    shiny::radioButtons(
      inputId = ns("correlation_method"),
      label = "Inter feature correlation method",
      choices = c("SparCC" = "sparcc", "BAnOCC" = "banocc", "Spearman" = "spearman"),
      selected = "SparCC"
    ) %>% update_label(),
    shiny::uiOutput(ns("panel_banocc")),
    shiny::uiOutput(ns("panel_sparcc"))
  )
}

#' @param ns name space as generated by shiny::NS
panel_features <- function(ns, ...) {
  shinyBS::bsCollapsePanel(
    ...,
    title = "Feature generation",
    shiny::radioButtons(
      inputId = ns("taxonomic_rank"),
      label = "Taxonomic rank",
      choices = c(
        "Strain" = "strain", "Species" = "species", "Genus" = "genus",
        "Family" = "family", "Order" = "order", "Class" = "class", "Phylum" = "phylum"
      ),
      selected = "species"
    ) %>% update_label(),
    shiny::radioButtons(
      inputId = ns("phylo_database"),
      label = "Phylogeny",
      choices = "index_fungorum_2016",
      selected = "index_fungorum_2016"
    ) %>% update_label(),
    shiny::numericInput(
      inputId = ns("min_abundance"),
      label = "Minimum abundance to count prevalence (%)",
      value = 0.01,
      min = 0,
      max = 100,
    ) %>% update_label(),
    shiny::numericInput(
      inputId = ns("min_prevalence"),
      label = "Minimum prevalence (%)",
      value = 5,
      min = 0,
      max = 100,
    ) %>% update_label(),
    shiny::textInput(
      inputId = ns("group_prevalence"),
      value = "all",
      label = "Prevalence group"
    ) %>% update_label(),
    shiny::radioButtons(
      inputId = ns("normalization_method"),
      label = "Normalization method",
      choices = c(
        "CLR (centered log-ratio)" = "clr", "CSS (Cumulative sum scaling)" = "css", "TSS (Total sum scaling)" = "tss",
        "Rarefaction" = "rarefaction", "Raw (No normalization)" = "raw"
      ),
      selected = "clr"
    ) %>% update_label(),
    shiny::radioButtons(
      inputId = ns("unknown_strategy"),
      label = "Unknown strategy",
      choices = c(
        "Remove unknown sequences" = "remove", "Infer taxon names from upstream taxonomic ranks and add sp." = "infer"
      ),
      selected = "remove"
    ) %>% update_label()
  )
}

panel_blast <- function(ns = NS("start_mod")) {
  shiny::div(
    shiny::numericInput(
      inputId = ns("frac_identity"),
      label = "Minimum BLAST identity (fraction)",
      value = 0.8,
      min = 0,
      max = 1,
      step = 0.01
    ) %>% update_label()
  )
}

#' @param ns name space as generated by shiny::NS
panel_phylotyping <- function(ns, ...) {
  shinyBS::bsCollapsePanel(
    ...,
    title = "Phylotyping",
    shiny::radioButtons(
      inputId = ns("ref_database"),
      label = "Reference database",
      choices = "unite_8.0_dynamic",
      selected = "unite_8.0_dynamic"
    ) %>% update_label(),
    shiny::radioButtons(
      inputId = ns("sequence_classifier"),
      label = "Sequence classifier",
      choices = c("Qiime2 BLAST Consensus" = "qiime2_blast", "Qiime2 Naive Bayes" = "qiime2_nb"),
      selected = "qiime2_nb"
    ) %>% update_label(),
    shiny::uiOutput(ns("panel_blast"))
  )
}

panel_pipits <- function(ns = shiny::NS("start_mod")) {
  shiny::div(
    shiny::checkboxInput(
      inputId = ns("include_singletons"),
      label = "PIPITS Include singletons",
      value = FALSE
    ) %>% update_label(),
    shiny::numericInput(
      inputId = ns("identity_threshold"),
      label = "PIPITS identity threshold",
      value = 0.97,
      min = 0,
      max = 1,
      step = 0.01
    ) %>% update_label()
  )
}

panel_dada2 <- function(ns = shiny::NS("start_mod")) {
  shiny::div(
    # shiny::numericInput(
    #   inputId = ns("max_n"),
    #   label = "Maximal number of undefined bases",
    #   value = 0,
    #   min = 0,
    # ) %>% update_label(),
    shiny::numericInput(
      inputId = ns("min_q"),
      label = "DADA2 Minimal base quality",
      value = 0,
      min = 0,
    ) %>% update_label(),
    shiny::numericInput(
      inputId = ns("trunc_q"),
      label = "DADA2 truncate quality",
      value = 2,
      min = 0,
    ) %>% update_label(),
    shiny::textInput(
      inputId = ns("max_ee"),
      label = "DADA2 Maximal expected errors",
      value = "2,2",
    ) %>% update_label()
  )
}

#' @param ns name space as generated by shiny::NS
panel_denoising <- function(ns, ...) {
  bsCollapsePanel(
    ...,
    title = "Denoising",
    shiny::radioButtons(
      inputId = ns("its_region"),
      label = "ITS region",
      choices = c("ITS1", "ITS2")
    ) %>% update_label(),
    shiny::radioButtons(
      inputId = ns("denoising_method"),
      label = "Denoising method",
      choices = c("OTU (PIPITS)" = "otu_pipits", "ASV (DADA2)" = "asv_dada2"),
      selected = "asv_dada2"
    ) %>% update_label(),
    shiny::uiOutput(ns("panel_dada2")),
    shiny::uiOutput(ns("panel_pipits"))
  )
}


#' @param ns name space as generated by shiny::NS
panel_qc <- function(ns, ...) {
  bsCollapsePanel(
    ...,
    title = "Quality Control",
    shiny::textAreaInput(
      inputId = ns("adapter_fasta"),
      label = "Sequences to trim (Adapters and primers in FASTA format)",
      placeholder = ">Forward primer ITS3\nGCATCGATGAAGAACGCAGC\n>Reverse primer ITS4\nTCCTCCGCTTATTGATATGC",
      height = "100px"
    ) %>% update_label(),
    shiny::checkboxGroupInput(
      inputId = ns("additional_adapter_files"),
      label = "Additional adapters",
      choices = c("NexteraPE-PE.fa", "TruSeq2-PE.fa", "TruSeq3-PE-2.fa", "TruSeq2-SE.fa", "TruSeq3-SE.fa"),
      selected = c("NexteraPE-PE.fa", "TruSeq2-PE.fa", "TruSeq3-PE-2.fa")
    ) %>% update_label(),
    shiny::checkboxInput(
      inputId = ns("include_revcomp_primers"),
      label = "Include reverse complement of primer sequences",
      value = TRUE
    ) %>% update_label(),
    shiny::radioButtons(
      inputId = ns("phred_format"),
      label = "Phred Score Format",
      choices = c("phred33", "phred64"),
      selected = "phred33"
    ) %>% update_label(),
    shiny::numericInput(
      inputId = ns("min_quality_leading"),
      label = "Minimim quality of leading bases (Phred)",
      value = 25
    ) %>% update_label(),
    shiny::numericInput(
      inputId = ns("min_quality_trailing"),
      label = "Minimim quality of trailing bases (Phred)",
      value = 25
    ) %>% update_label(),
    shiny::numericInput(
      inputId = ns("qc_error_rate"),
      label = "Maximum allowed error rate",
      value = 0.1,
      step = 0.05
    ) %>% update_label(),
    shiny::numericInput(
      inputId = ns("min_read_length"),
      label = "Minimum read length (bp)",
      value = 50
    ) %>% update_label(),
    shiny::numericInput(
      inputId = ns("min_qc_read_count"),
      label = "Minimum number of QC reads",
      value = 1000
    ) %>% update_label(),
    shiny::checkboxGroupInput(
      inputId = ns("qc_exclusion_criteria"),
      label = "Exclude sample if any of these tests failed",
      choices = c(
        "Adapter content" = "fastqc_adapter_content_failed",
        "Per base N content" = "fastqc_per_base_n_content_failed",
        "Per base sequence quality" = "fastqc_per_base_sequence_quality_failed",
        "Per sequence quality scores" = "fastqc_per_sequence_quality_scores_failed",
        "Per tile sequence quality" = "fastqc_per_tile_sequence_quality_failed",
        "Sequence length distribution" = "fastqc_per_sequence_length_distribution_failed",
        "Minimum number of QC reads" = "min_qc_read_count_failed"
      ),
      selected = c(
        "fastqc_adapter_content_failed", "fastqc_per_base_n_content_failed",
        "fastqc_per_base_sequence_quality_failed", "fastqc_per_sequence_quality_scores_failed",
        "fastqc_sequence_length_distribution_failed", "min_qc_read_count_failed"
      )
    ) %>% update_label()
  )
}

remove_muxed <- function(samples, input_mod) {
  samples_tbl <- input_mod$samples_tbl()

  # no need to remove muxed samples if no mux info in samples table
  if (!"barcode_file" %in% colnames(samples_tbl)) {
    return(samples)
  }

  #' remove  multiplexed read files from list
  pattern <-
    samples_tbl %>%
    dplyr::pull(barcode_file) %>%
    base::unique() %>%
    base::setdiff(NA) %>%
    base::paste(collapse = " | ")

  if (pattern == "") {
    # nothing to remove
    return(samples)
  } else {
    return(base::grep(pattern, samples, value = TRUE, invert = TRUE))
  }
}

save_project_json <- function(project, input, input_mod) {
  # adding default parameter set to project
  input_l <- shiny::isolate(reactiveValuesToList(input))

  # missing params occur if the ui was never rendered. Use defaults instead
  missing_params <-
    ALL_PARAM_SET %>%
    setdiff(names(input))

  missing_params_l <-
    params_tbl %>%
    dplyr::filter(id %in% missing_params) %>%
    dplyr::select(id, default) %>%
    tidyr::spread(id, default) %>%
    readr::type_convert() %>%
    as.list()

  input_l <- c(input_l, missing_params_l)

  qc_params <- input_l[QC_PARAM_SET]
  denoising_params <- input_l[DENOISING_PARAM_SET]
  phylotyping_params <- input_l[PHYLOTYPING_PARAM_SET]
  features_params <- input_l[FEATURES_PARAM_SET]
  analysis_params <- input_l[ANALYSIS_PARAM_SET] %>% c(DEFAULT_ANALYSIS_PARAM_SET)

  res <- project
  res$email_address <- isolate(input$email_address)

  res$params <- base::list(
    qc_params = list() %>% magrittr::inset(SELECTED_STEPS$qc, list(qc_params)),
    denoising_params = list() %>% magrittr::inset(SELECTED_STEPS$denoising, list(denoising_params)),
    phylotyping_params = list() %>% magrittr::inset(SELECTED_STEPS$phylotyping, list(phylotyping_params)),
    features_params = list() %>% magrittr::inset(SELECTED_STEPS$features, list(features_params)),
    analysis_params = list() %>% magrittr::inset(SELECTED_STEPS$analysis, list(analysis_params))
  )

  # set step dependencies
  res[[c("params", "denoising_params", SELECTED_STEPS$denoising, "selected_qc_params")]] <- SELECTED_STEPS$qc
  res[[c("params", "phylotyping_params", SELECTED_STEPS$phylotyping, "selected_denoising_params")]] <- SELECTED_STEPS$denoising
  res[[c("params", "features_params", SELECTED_STEPS$features, "selected_phylotyping_params")]] <- SELECTED_STEPS$phylotyping
  res[[c("params", "analysis_params", SELECTED_STEPS$analysis, "selected_features_params")]] <- SELECTED_STEPS$features
  res[["selected_analysis_params"]] <- SELECTED_STEPS$analysis

  none_to_empty_vector <- function(x) {
    base::ifelse(
      is.null(x) | x == "" | is_empty(x),
      base::list(), x
    )
  }

  muxed_samples <- NULL
  if ({
    # multiplexing data available
    input_mod$samples_tbl() %>%
      base::colnames() %>%
      base::intersect(c("barcode_seq", "barcode_file")) %>%
      base::length() == 2
  }) {
    muxed_samples <-
      input_mod$samples_tbl() %>%
      tidyr::drop_na(barcode_seq, barcode_file) %>%
      dplyr::pull(sample_id) %>%
      base::unique()
  }

  project_sra_ids <- input_mod$projects() %>% pluck("samples")
  sra_ids <-
    input_mod$sra_ids %>%
    stringr::str_split("\n") %>%
    purrr::simplify() %>%
    union(project_sra_ids) %>%
    base::unique() %>%
    base::setdiff("") %>%
    none_to_empty_vector()

  res$input <- base::list(
    projects = input_mod$projects() %>% shiny::isolate(),
    sra_ids = sra_ids,
    local_samples = base::paste(project$project_dir, "input", "reads", sep = "/") %>%
      base::list.files() %>%
      # sample id is everything up to the first point
      stringr::str_remove("_?[12]?\\..*$") %>%
      base::unique() %>%
      remove_muxed(input_mod) %>%
      none_to_empty_vector(),
    muxed_samples = muxed_samples %>% none_to_empty_vector(),
    meta_samples =
      input_mod$samples_tbl() %>%
        purrr::pluck(1) %>%
        base::unique() %>%
        none_to_empty_vector()
  )

  # save only if parameters changed
  # otherwise the whole pipeline will rerun
  # use json string for comparison so list() and "" is the same
  project_json_path <- base::paste(project$project_dir, "input", "project.json", sep = "/")

  new_state <- res
  new_state$start_datetime <- NULL
  new_state <- jsonlite::toJSON(new_state)

  old_state <- ""
  if (base::file.exists(project_json_path)) {
    x <- jsonlite::fromJSON(project_json_path)
    x$start_datetime <- NULL
    old_state <- jsonlite::toJSON(x)
  }
  update_needed <- base::as.character(old_state) != base::as.character(new_state)

  if (update_needed) {
    message("save changed project to project.json")

    input_dir <- base::paste0(project$project_dir, "/input")
    if (!dir.exists(input_dir)) {
      dir.create(input_dir, recursive = TRUE)
    }

    res %>%
      jsonlite::toJSON(pretty = TRUE, auto_unbox = TRUE) %>%
      readr::write_file(project_json_path)

    input_mod$samples_tbl() %>%
      readr::write_csv(paste0(input_dir, "/samples.csv"))
  }

  return(update_needed)
}

start_mod_UI <- function(id) {
  ns <- NS(id)

  shiny::fluidRow(
    shiny::h1("Start"),
    shiny::div(
      paste0(
        "This page is about starting the analysis pipeline.",
        "Parameter sets can be created here to customize the workflow."
      )
    ),
    shiny::h2("Start pipeline"),
    shiny::textInput(
      inputId = ns("email_address"),
      placeholder = "info@example.com",
      label = "Email address"
    ) %>% update_label(),
    shiny::actionButton(
      inputId = ns("start_pipeline"),
      label = "Start pipeline",
      icon = shiny::icon("play")
    ),
    shiny::h2("Customize parameter"),
    shiny::div(
      "Click on the panel to customize parameters of this particular step"
    ),
    bsCollapse(
      panel_qc(ns),
      panel_denoising(ns),
      panel_phylotyping(ns),
      panel_features(ns),
      panel_analysis(ns)
    )
  )
}

update_choices <- function(csv_path, session, input_id) {
  tbl <- readr::read_csv(csv_path)
  res <- tbl$id
  names(res) <- tbl$name

  shiny::updateRadioButtons(
    session = session,
    inputId = input_id,
    choices = res,
    selected = tbl$id[1]
  )
}

start_mod <- function(input, output, session, project, input_mod) {
  # update data bases
  update_choices(REF_DB_CSV, session, "ref_database")
  update_choices(PHYLO_DB_CSV, session, "phylo_database")

  #
  # display conditional UI elements
  #
  output$panel_pipits <- shiny::renderUI(panel_pipits())
  output$panel_dada2 <- shiny::renderUI(panel_dada2())
  output$panel_blast <- shiny::renderUI(panel_blast())
  message("here")

  shiny::observeEvent(
    eventExpr = input$denoising_method,
    handlerExpr = {
      switch(input$denoising_method,
        "otu_pipits" = {
          output$panel_pipits <- shiny::renderUI(panel_pipits())
          output$panel_dada2 <- NULL
        },
        "asv_dada2" = {
          output$panel_pipits <- NULL
          output$panel_dada2 <- shiny::renderUI(panel_dada2())
        }
      )
    }
  )

  shiny::observeEvent(
    eventExpr = input$sequence_classifier,
    handlerExpr = {
      switch(input$sequence_classifier,
        "qiime2_blast" = {
          output$panel_blast <- shiny::renderUI(panel_blast())
        },
        {
          output$panel_blast <- NULL
        }
      )
    }
  )

  shiny::observeEvent(
    eventExpr = input$correlation_method,
    handlerExpr = {
      switch(input$correlation_method,
        "banocc" = {
          output$panel_banocc <- shiny::renderUI(panel_banocc())
          output$panel_sparcc <- NULL
        },
        "sparcc" = {
          output$panel_banocc <- NULL
          output$panel_sparcc <- shiny::renderUI(panel_sparcc())
        },
        {
          output$panel_sparcc <- NULL
          output$panel_banocc <- NULL
        }
      )
    }
  )

  #
  # Start pipeline
  #

  shiny::observeEvent(
    eventExpr = input$start_pipeline,
    handlerExpr = {
      if (project$project_id == "example") {
        shiny::showNotification(
          ui = "The example project is read-only and already processed",
          type = "warning",
          duration = 15
        )
        return()
      }

      # Ensure file compression is finished
      if(
        paste0(USERDAT_DIR, "/", project$project_id, "/input/reads") %>%
        list.files() %>%
        purrr::keep(~ .x %>% stringr::str_ends(".gz.tmp")) %>%
        length() > 0
      ) {
        shiny::showNotification(
          ui = "Please wait until uploaded files are compressed",
          duration = 15
        )
        return()
      }

      update_needed <- save_project_json(project, input, isolate(input_mod))

      if (update_needed) {
        # add project to queue file
        sprintf("echo %s >> %s/queue", project$project_id, USERDAT_DIR) %>%
          system()

        queue_position <-
          sprintf("wc -l %s/queue", USERDAT_DIR) %>%
          system(intern = TRUE) %>%
          stringr::str_extract("^[0-9]+")

        shiny::modalDialog(
          title = "Pipeline started",
          easyClose = TRUE,
          paste(
            "The pipeline has been successfully started.\n",
            "<br>Please remember your project ID: ",
            project$project_id,
            "<br>Your position in the queue: ",
            queue_position,
            "<br>Results will be accessible on the sidebar.",
            "Please refresh your browser by typing F5 for updates.",
            collapse = " "
          ) %>% shiny::HTML()
        ) %>%
          shiny::showModal()
      } else {
        shiny::showNotification(
          ui = "Analysis already up to date. Parameters didn't change.",
          duration = 15
        )
      }
    }
  )
}
